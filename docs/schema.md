# Database SchemaThis document specifies the SQLite schema for `es-stats`.Design goals:- Canonical storage at 1-minute granularity (`bars_1m`)- Deterministic derived storage at 30-minute granularity (`bars_30m`)- Fast range queries (charting) and fast day/session queries (analytics)- Avoid ORM; SQL-first; repositories load `.sql` filesTime/session rules are defined in `docs/time_rules.md` and are authoritative.---## Conventions### Timestamp storage- All stored bar timestamps are **epoch seconds** (INTEGER) representing the bar start instant:  - `ts_start_utc` for 1m bars  - `bucket_start_utc` for 30m bars### CT helper fieldsTo avoid runtime timezone conversion for analytics:- `trading_date_ct_int`: INTEGER `YYYYMMDD` based on CT 17:00 rollover- `ct_minute_of_day`: INTEGER `0..1439` based on CT local bar start minute### Session identifiersSessions are defined in CT:- ON: 17:00:00–08:29:59 CT- RTH: 08:30:00–15:59:59 CT- 16:00:00–16:59:59 CT is out-of-session in v1 unless explicitly required---## Tables### 1) `instruments`Registry of symbols/instruments.**Columns**- `instrument_id` INTEGER PRIMARY KEY- `symbol` TEXT NOT NULL UNIQUE- `description` TEXT NULL- `tz_exchange` TEXT NOT NULL DEFAULT 'America/Chicago'**Notes**- `tz_exchange` is informational; canonical session logic is CT per Phase 0.---### 2) `imports`Audit trail of admin/server-side imports.**Columns**- `import_id` INTEGER PRIMARY KEY- `instrument_id` INTEGER NOT NULL REFERENCES instruments(instrument_id)- `source_name` TEXT NOT NULL                 -- filename or dataset label- `source_hash` TEXT NULL                     -- optional hash for repeat detection- `input_timezone` TEXT NOT NULL DEFAULT 'America/Chicago'- `bar_interval_seconds` INTEGER NOT NULL DEFAULT 60- `merge_policy` TEXT NOT NULL                -- 'skip' or 'overwrite'  - CHECK (merge_policy IN ('skip','overwrite'))- `started_at_utc` INTEGER NOT NULL- `finished_at_utc` INTEGER NULL- `ts_min_utc` INTEGER NULL                   -- min ts_start_utc observed- `ts_max_utc` INTEGER NULL                   -- max ts_start_utc observed- `row_count_read` INTEGER NOT NULL DEFAULT 0- `row_count_inserted` INTEGER NOT NULL DEFAULT 0- `row_count_updated` INTEGER NOT NULL DEFAULT 0- `row_count_rejected` INTEGER NOT NULL DEFAULT 0- `status` TEXT NOT NULL                      -- 'success' or 'failed'  - CHECK (status IN ('success','failed'))- `error_summary` TEXT NULL**Indexes**- `idx_imports_instrument_started` on (`instrument_id`, `started_at_utc` DESC)**Notes**- Imports are admin-only (CLI for v1).- `bar_interval_seconds` is fixed at 60 for v1 but stored for audit correctness.---### 3) `bars_1m`Canonical 1-minute OHLCV bars.**Columns**- `instrument_id` INTEGER NOT NULL REFERENCES instruments(instrument_id)- `ts_start_utc` INTEGER NOT NULL                         -- epoch seconds- `trading_date_ct_int` INTEGER NOT NULL                  -- YYYYMMDD- `ct_minute_of_day` INTEGER NOT NULL                     -- 0..1439- `open` REAL NOT NULL- `high` REAL NOT NULL- `low` REAL NOT NULL- `close` REAL NOT NULL- `volume` INTEGER NOT NULL- `source_import_id` INTEGER NULL REFERENCES imports(import_id)**Primary key**- PRIMARY KEY (`instrument_id`, `ts_start_utc`)**Constraints**- CHECK (`ct_minute_of_day` BETWEEN 0 AND 1439)- CHECK (`volume` >= 0)- CHECK (`high` >= `low`)- (optional, stricter) CHECK (`high` >= `open` AND `high` >= `close`)- (optional, stricter) CHECK (`low` <= `open` AND `low` <= `close`)**Indexes**- `idx_bars_1m_inst_ts` on (`instrument_id`, `ts_start_utc`)- `idx_bars_1m_inst_day_minute` on (`instrument_id`, `trading_date_ct_int`, `ct_minute_of_day`, `ts_start_utc`)- `idx_bars_1m_inst_day_ts` on (`instrument_id`, `trading_date_ct_int`, `ts_start_utc`)**Notes**- `trading_date_ct_int` and `ct_minute_of_day` are computed at import time using `docs/time_rules.md`.- `source_import_id` is optional and intended for traceability, not for uniqueness.---### 4) `bars_30m`Derived 30-minute OHLCV bars computed deterministically from `bars_1m`.**Columns**- `instrument_id` INTEGER NOT NULL REFERENCES instruments(instrument_id)- `bucket_start_utc` INTEGER NOT NULL                      -- epoch seconds (30m-aligned in CT, stored as UTC epoch)- `trading_date_ct_int` INTEGER NOT NULL                   -- YYYYMMDD- `bucket_ct_minute_of_day` INTEGER NOT NULL               -- 0..1439, must be a multiple of 30- `session` TEXT NULL                                      -- 'ON' or 'RTH' or NULL (out-of-session)  - CHECK (session IN ('ON','RTH') OR session IS NULL)- `period_index` INTEGER NULL                              -- integer period within session, per Phase 0 rules- `tpo` TEXT NULL                                          -- display label derived from period_index (may be >1 char)- `open` REAL NOT NULL- `high` REAL NOT NULL- `low` REAL NOT NULL- `close` REAL NOT NULL- `volume` INTEGER NOT NULL- `bar_count_1m` INTEGER NOT NULL                          -- number of 1m bars aggregated (0..30)- `is_complete` INTEGER NOT NULL DEFAULT 0                 -- 1 if bar_count_1m == 30 else 0  - CHECK (is_complete IN (0,1))- `derived_from_import_id` INTEGER NULL REFERENCES imports(import_id)**Primary key**- PRIMARY KEY (`instrument_id`, `bucket_start_utc`)**Constraints**- CHECK (`bucket_ct_minute_of_day` BETWEEN 0 AND 1439)- CHECK (`bucket_ct_minute_of_day` % 30 = 0)- CHECK (`bar_count_1m` BETWEEN 0 AND 30)- CHECK (`volume` >= 0)- CHECK (`high` >= `low`)- (optional) CHECK (`is_complete` = CASE WHEN `bar_count_1m` = 30 THEN 1 ELSE 0 END)**Indexes**- `idx_bars_30m_inst_ts` on (`instrument_id`, `bucket_start_utc`)- `idx_bars_30m_inst_day_ts` on (`instrument_id`, `trading_date_ct_int`, `bucket_start_utc`)- `idx_bars_30m_inst_day_session_period` on (`instrument_id`, `trading_date_ct_int`, `session`, `period_index`)**Notes**- `period_index` is authoritative for period math. `tpo` is optional and for display.- Because ON has 30 buckets, `tpo` must allow labels longer than 1 character if persisted.---## Derived data rules (30m rebuild)`bars_30m` is a cache derived from `bars_1m`. It must be rebuilt deterministically.### Rebuild triggerAfter importing/upserting `bars_1m` for an instrument over an affected time range:- rebuild 30m buckets for the overlapping bucket range- scope rebuild to only affected instruments and time windows (not full table)### Aggregation semantics (1m -> 30m)For each 30m bucket:- `open`  = `open` of the earliest 1m bar in bucket- `close` = `close` of the latest 1m bar in bucket- `high`  = max(`high`) across 1m bars in bucket- `low`   = min(`low`) across 1m bars in bucket- `volume` = sum(`volume`) across 1m bars in bucket- `bar_count_1m` = count of 1m bars in bucket- `is_complete` = 1 if `bar_count_1m` == 30 else 0### Session + period fieldsFor each 30m bucket, compute in CT:- `bucket_ct_minute_of_day`- `session` based on Phase 0 ON/RTH definitions- `period_index` per Phase 0 formulas- optional `tpo` derived from (`session`, `period_index`)Buckets in the 16:00–16:59 CT window:- `session` = NULL- `period_index` = NULL- `tpo` = NULL---## Query patterns and index rationaleExpected high-frequency queries:1) Range fetch for charting:   - by (`instrument_id`, `ts_start_utc` range) or (`bucket_start_utc` range)2) Day/session slices:   - by (`instrument_id`, `trading_date_ct_int`) and `ct_minute_of_day` filters (1m)   - by (`instrument_id`, `trading_date_ct_int`, `session`, `period_index`) (30m)3) Rolling window statistics over many days:   - use `bars_30m` where possible for efficiencyThe proposed indexes are chosen to keep these queries index-friendly in SQLite.---## Normalization and key design notesThis schema intentionally stores some time-derived helper fields (e.g., `trading_date_ct_int`, `ct_minute_of_day`, and `bucket_ct_minute_of_day`). These fields are functionally determined by the timestamp (under the rules in `docs/time_rules.md`) and therefore the bar tables are not strictly in 2NF/3NF/BCNF. This is a deliberate denormalization to:- keep analytics queries index-friendly (day/session slicing without repeated timezone logic),- avoid pushing DST/timezone/session computations into SQL at query time,- reduce application-side recomputation for common filters and groupings.Correctness requirement: these derived fields must be computed consistently during import (`bars_1m`) and during rebuild/refresh (`bars_30m`). They are treated as materialized, verified outputs of the ingestion pipeline.### Composite primary keys`bars_1m` and `bars_30m` use composite primary keys:- `bars_1m`: (`instrument_id`, `ts_start_utc`)- `bars_30m`: (`instrument_id`, `bucket_start_utc`)Rationale:- This matches the natural identity of a bar (instrument + time bucket) and prevents duplicates at the database level.- It aligns with the dominant query pattern (per-instrument range scans over time).- It simplifies import merge policy implementation via `ON CONFLICT`/upsert logic without introducing a surrogate bar ID that would still require a uniqueness constraint on (instrument, timestamp).---## Open items (schema-affecting)- Future additions may include:  - holiday/early-close calendar table (if needed)  - additional derived intervals (5m/60m) if performance requires it  - computed metrics tables for expensive analytics (only if necessary)