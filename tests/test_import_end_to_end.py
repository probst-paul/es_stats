from __future__ import annotationsimport sqlite3from pathlib import Pathfrom es_stats.repositories.sql_loader import load_sqlfrom es_stats.cli.main import build_parser, import_csv_contract_onlydef _init_db(db_path: Path) -> None:    conn = sqlite3.connect(str(db_path))    try:        conn.execute("PRAGMA foreign_keys = ON;")        conn.executescript(load_sql("schema/001_init.sql"))        conn.commit()    finally:        conn.close()def test_import_end_to_end_imports_1m_and_rebuilds_30m(tmp_path: Path, monkeypatch):    # --------------------    # Arrange    # --------------------    db_path = tmp_path / "test.sqlite3"    _init_db(db_path)    # Make the app use this temp DB (your code already supports env-driven db path)    monkeypatch.setenv("ES_STATS_DB_PATH", str(db_path))    # Build a CSV that spans TWO 30m buckets:    # - 08:30..08:59 (30 rows) => complete bucket    # - 09:00..09:01 (2 rows)  => partial bucket    csv_path = tmp_path / "bars.csv"    lines = ["datetime,open,high,low,last,volume\n"]    # 32 rows total, 1-minute interval, all within RTH    # 2025-01-01 08:30 to 09:01    start_hour, start_min = 8, 30    for i in range(32):        total_min = start_min + i        hh = start_hour + (total_min // 60)        mm = total_min % 60        dt = f"2025-01-01 {hh:02d}:{mm:02d}"        o = 100.0 + i        h = o + 1.0        l = o - 1.0        c = o + 0.5        v = 1        lines.append(f"{dt},{o},{h},{l},{c},{v}\n")    csv_path.write_text("".join(lines))    parser = build_parser()    args = parser.parse_args(        [            "import-csv",            "--file",            str(csv_path),            "--symbol",            "ES",            "--timezone",            "America/Chicago",            "--merge-policy",            "skip",        ]    )    # --------------------    # Act    # --------------------    rc = import_csv_contract_only(args, parser)    # --------------------    # Assert    # --------------------    assert rc == 0    conn = sqlite3.connect(str(db_path))    try:        conn.row_factory = sqlite3.Row        # 1) imports audit row exists and is success        imp = conn.execute(            """            SELECT import_id, status, row_count_read, row_count_inserted, row_count_updated            FROM imports            ORDER BY import_id DESC            LIMIT 1;            """        ).fetchone()        assert imp is not None        assert imp["status"] == "success"        assert imp["row_count_read"] == 32        assert imp["row_count_inserted"] == 32        assert imp["row_count_updated"] == 0        # 2) bars_1m has exactly 32 rows        c1m = conn.execute(            "SELECT COUNT(*) AS n FROM bars_1m;").fetchone()["n"]        assert c1m == 32        # 3) bars_30m has 2 rows (08:30 bucket + 09:00 bucket)        c30m = conn.execute(            "SELECT COUNT(*) AS n FROM bars_30m;").fetchone()["n"]        assert c30m == 2        # 4) Verify the complete 08:30 bucket (bucket_ct_minute_of_day = 510)        r_0830 = conn.execute(            """            SELECT bucket_ct_minute_of_day, bar_count_1m, is_complete,                   open, high, low, close, volume,                   session, period_index            FROM bars_30m            WHERE bucket_ct_minute_of_day = 510;            """        ).fetchone()        assert r_0830 is not None        assert int(r_0830["bar_count_1m"]) == 30        assert int(r_0830["is_complete"]) == 1        # open = first open in that bucket (i=0 => 100.0)        assert float(r_0830["open"]) == 100.0        # close = last close in that bucket (i=29 => 129.5)        assert float(r_0830["close"]) == 129.5        # high = max(high) (i=29 => 130.0)        assert float(r_0830["high"]) == 130.0        # low = min(low) (i=0 => 99.0)        assert float(r_0830["low"]) == 99.0        # volume sum = 30 * 1        assert int(r_0830["volume"]) == 30        assert r_0830["session"] == "RTH"        assert int(r_0830["period_index"]) == 0        # 5) Verify the partial 09:00 bucket (bucket_ct_minute_of_day = 540)        r_0900 = conn.execute(            """            SELECT bucket_ct_minute_of_day, bar_count_1m, is_complete,                   open, high, low, close, volume,                   session, period_index            FROM bars_30m            WHERE bucket_ct_minute_of_day = 540;            """        ).fetchone()        assert r_0900 is not None        assert int(r_0900["bar_count_1m"]) == 2        assert int(r_0900["is_complete"]) == 0        # open = i=30 => 130.0        assert float(r_0900["open"]) == 130.0        # close = i=31 => 131.5        assert float(r_0900["close"]) == 131.5        # high = max(high) among i=30..31 => i=31 high = 132.0        assert float(r_0900["high"]) == 132.0        # low = min(low) among i=30..31 => i=30 low = 129.0        assert float(r_0900["low"]) == 129.0        # volume sum = 2 * 1        assert int(r_0900["volume"]) == 2        assert r_0900["session"] == "RTH"        assert int(r_0900["period_index"]) == 1    finally:        conn.close()